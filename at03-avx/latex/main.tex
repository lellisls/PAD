\documentclass[conference]{IEEEtran}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{cite}
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
\usepackage[cmex10]{amsmath}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{mdwmath}
\usepackage{mdwtab}
%\usepackage{eqparbox}
\usepackage[tight,footnotesize]{subfigure}
%\usepackage[caption=false]{caption}
\usepackage[font=footnotesize]{subfig}
%\usepackage{stfloats}
\usepackage{url}
\usepackage{csvsimple,longtable,booktabs}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\hyphenation{op-tical net-works semi-conduc-tor}

\usepackage{listings}

\lstset{language=C++,
        basicstyle=\ttfamily,
        keywordstyle=\color{blue}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{green}\ttfamily,
        morecomment=[l][\color{magenta}]{\#}
}


\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
  \else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
\usepackage[cmex10]{amsmath}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{mdwmath}
\usepackage{mdwtab}
%\usepackage{eqparbox}
\usepackage[tight,footnotesize]{subfigure}
%\usepackage[caption=false]{caption}
\usepackage[font=footnotesize]{subfig}
%\usepackage{stfloats}
\usepackage{url}
\usepackage{csvsimple,longtable,booktabs}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}
\title{Programação de Alto Desempenho\\
\large Atividade 3 - Otimização por vetorização}

\author{\IEEEauthorblockN{Lucas Santana Lellis - 69618}
\IEEEauthorblockA{PPGCC - Instituto de Ciência e Tecnologia\\
	Universidade Federal de São Paulo} }

% make the title area
\maketitle

%\IEEEpeerreviewmaketitle

\section{Introdução}
Nesta atividade foram realizados experimentos relacionados com a vetorização de laços, que pode ser realizada de forma automática pelo computador, mas também utilizando-se funções intrínsecas das arquiteturas sse, avx e avx2.
Cada experimento foi realizado 5 vezes, e os resultados apresentados são a média dos resultados obtidos em cada um deles.

Todos os programas foram feitos em C, com as flags ``-O3 -msse -ftree-vectorize -fopt-info-vec-all'', utilizando a biblioteca PAPI para estimar o tempo total de processamento, o total de operações de ponto flutuante (PAPI\_SP\_OPS), e o fator de Ciclos por elementos do vetor (CPE).

As especificações da máquina utilizada estão disponíveis na Tabela \ref{tab:cpu}.

\begin{table}[htb!]
\centering
\caption{Especificações da Máquina}
\label{tab:cpu}
\begin{tabular}{rl}
\bf{PAPI Version            } & 5.4.3.0 \\
\bf{Model string and code   } & Intel Core i5-2400\\
\bf{CPU Revision            } & 7.000000 \\
\bf{CPU Max Megahertz       } & 3101 \\
\bf{CPU Min Megahertz       } & 1600 \\
\bf{Threads per core        } & 1 \\
\bf{Cores per Socket        } & 4 \\
\bf{Number Hardware Counters} & 11 \\
\bf{Max Multiplex Counters  } & 192 \\
\bf{Cache L3                } & 6144 KB \\
\bf{Cache L2                } & 256 KB * 4 \\
\bf{RAM                     } & 4 Gb \\
\bf{SO                      } & Ubuntu 14.04 x64 \\
\bf{Kernel                  } & 3.13.0-46-generic \\
\bf{GCC                     } & 6.1.1 20160511\\
\end{tabular}
\end{table}

\section{Experimento 1}
Nesse experimento foram feitos diversos testes envolvendo 6 diferentes tipos de cálculos, sendo avaliada a capacidade do compilador em vetorizá-los automaticamente, sendo feitas também as adaptações possíveis e necessárias para que isso seja possível, sendo também implementadas versões vetorizadas fazendo-se uso de funções intrínsecas do padrão avx.

\subsection{Algoritmo 1}
O primeiro algoritmo consiste no seguinte cálculo:

\begin{lstlisting}
  for (i=1; i<N; i++) {
    x[i] = y[i] + z[i];
    a[i] = x[i-1] + 1.0;
  }
\end{lstlisting}

Ao compilar este exemplo com a flag ``-fopt-info-vec-all'', pudemos observar a seguinte mensagem: ``src/exercicio\_a.c:25:3: note: LOOP VECTORIZED'', que coincide exatamente com o laço descrito acima.

Assim, foi feita uma segunda versão, agora vetorizada por funções instrínsecas desse mesmo algoritmo:

\begin{lstlisting}
  ones = _mm256_set1_ps(1.0);
  for( i = 1; i < 8; i++ ) {
    x[ i ] = y[ i ] + z[ i ];
    a[ i ] = x[ i - 1 ] + 1.0;
  }
  for( i = 8; i < N - 8; i += 8 ) {
    v1 = _mm256_load_ps( y + i );
    v2 = _mm256_load_ps( z + i );
    v3 = _mm256_add_ps( v1, v2 );
    _mm256_store_ps( x + i, v3 );

    v1 = _mm256_load_ps( x + i -1 );
    v2 = _mm256_add_ps( v1, ones );
    _mm256_store_ps( a + i, v2 );
  }
  for( ; i < N; i++ ) {
    x[ i ] = y[ i ] + z[ i ];
    a[ i ] = x[ i - 1 ] + 1.0;
  }
\end{lstlisting}

A corretude do algoritmo é facilmente observável pelas operações aritméticas realizadas, e também pelos resultados obtidos ao final da execução dos dois programas.
Em um teste padronizado, em que os vetores são inicializados com os mesmos valores pseudo-aleatórios, temos o seguinte resultado nas dez ultimas posições do vetor $a$: \cite{wiki:BLAS}

\begin{table}[htb!]
\centering
\begin{tabular}{ l c c c c c c c c c c }
  Versao original & 173.41 & 195.57 & 75.57 & 156.35 & 283.08 \\
  & 22.80 & 357.32 & 338.45 & 254.81 & 265.32\\
  Versao vetorizada & 173.41 & 195.57 & 75.57 & 156.35 & 283.08 \\
  & 22.80 & 357.32 & 338.45 & 254.81 & 265.32\\
\end{tabular}
\end{table}
A comparação do desempenho se dá então pela Tabela \ref{tab:exp1.01}

\begin{table}[htb!]
	\centering
	\caption{Multiplicação de matrizes trivial comutando hierarquia de laços.}
	\label{tab:exp1.01}
	\begin{tabular}{lrrrr}%
		\bfseries Mode & \bfseries Tempo($\mu{s}$)& \bfseries L2\_DCM & \bfseries MFLOPS & \bfseries CPE
		\csvreader[]{tables/ex-a.csv}{}
		{\\\csvcoli & \csvcolii & \csvcoliii & \csvcoliv & \csvcolv}
	\end{tabular}
\end{table}

% \begin{figure}[htb!]
% \centering
% \caption{Comparação do tempo de execução entre as diferentes hierarquias.}
% \begin{tikzpicture}
% \begin{axis}[xlabel={Tamanho}, ylabel={Tempo ($\mu{s}$)}, legend pos=north west]
% \addplot gnuplot [raw gnuplot] {plot 'plots/ex01-time.txt' index 0};
% \addplot gnuplot [raw gnuplot] {plot 'plots/ex01-time.txt' index 1};
% \addplot gnuplot [raw gnuplot] {plot 'plots/ex01-time.txt' index 2};
% \addplot gnuplot [raw gnuplot] {plot 'plots/ex01-time.txt' index 3};
% \addplot gnuplot [raw gnuplot] {plot 'plots/ex01-time.txt' index 4};
% \addplot gnuplot [raw gnuplot] {plot 'plots/ex01-time.txt' index 5};
% \legend{$IJK$, $IKJ$, $JIK$, $JKI$, $KIJ$, $KJI$ }
% \end{axis}
% \end{tikzpicture}
% \label{fig:exp01-time}
% \end{figure}


% \begin{figure}[htb!]
% 	\centering
% 	\begin{tikzpicture}
% 	\begin{axis}[xlabel={Tamanho}, ylabel={Cache misses}, legend pos=north west]
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex01-l2dcm.txt' index 0};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex01-l2dcm.txt' index 1};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex01-l2dcm.txt' index 2};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex01-l2dcm.txt' index 3};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex01-l2dcm.txt' index 4};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex01-l2dcm.txt' index 5};
% 	\legend{$IJK$, $IKJ$, $JIK$, $JKI$, $KIJ$, $KJI$ }
% 	\end{axis}
% 	\end{tikzpicture}
% 	\caption{Comparação de cache-misses em memória cache L2 entre as diferentes hierarquias.}
% 	\label{fig:exp01-l2dcm}
% \end{figure}

%
% \section{Conclusão}
% Os experimentos realizados demonstraram a vantagem computacional obtida por meio da utilização de técnicas que favorecem a afinidade de memória, adequando-se a hierarquia dos laços, e também o impacto causado por diferentes estruturas de dados, de forma que se faça o uso mais eficiente do processador, evitando que este permaneça ocioso.
%
% Porém, isso não é o suficiente para se obter um desempenho ótimo do algoritmo, uma vez que os resultados variam de acordo com a complexidade dos problemas, e uma vez que desconhecemos todos os recursos adicionais presentes na arquitetura do processador, que o BLAS certamente faz uso. Isso também evidencia a superioridade e a importância da utilização de bibliotecas otimizadas de operações de álgebra linear na computação científica.
%
%
% Também notamos que a utilização de fusão de laços não necessariamente trará benefícios relevantes, pois o desempenho depende da natureza dos dados e também das operações realizadas à cada iteração. Já a utilização de diferentes estruturas de dados poderia apresentar diferenças mais expressivas em casos mais complexos, uma vez que não notamos uma diferença relevante nos experimentos simples realizados.
%
% Finalmente, a utilização das flags de otimização pode prejudicar a avaliação da diferença real do desempenho causada por cache misses, uma vez que recursos do processador, como as operações vetoriais, possam ser ativados automaticamente.

% \section{Experimento XXXX}
% Nesse experimento foi utilizada a função ..... do BLAS
%
% \begin{table}[htb!]
% 	\centering
% 	\caption{Desempenho obtido no exp XXXX}
% 	\label{tab:exp02}
% 	\begin{tabular}{ccccc}%
% 		\bfseries Size & \bfseries Tempo($\mu{s}$)& \bfseries L2\_DCM & \bfseries MFLOPS & \bfseries CPI
% 		\csvreader[]{tables/ex0XXXX.csv}{}
% 		{\\\csvcoli & \csvcolii & \csvcoliii & \csvcoliv & \csvcolv & \csvcolvi}
%
% 	\end{tabular}
% \end{table}
%
%
%
% \begin{figure}[htb!]
% 	\centering
% 	\begin{tikzpicture}
% 	\begin{axis}[xlabel={Tamanho}, ylabel={Tempo ($\mu{s}$)}, legend pos=north west]
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex0XXXX-time.txt' index 0};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex0XXXX-time.txt' index 1};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex0XXXX-time.txt' index 2};
% 	\legend{$16$, $32$ , $64$ }
% 	\end{axis}
% 	\end{tikzpicture}
% 	\caption{Comparação do tempo de execução entre os diferentes tamanhos minimos.}
% 	\label{fig:exp0XXXX-time}
% \end{figure}
%
%
% \begin{figure}[htb!]
% 	\centering
% 	\begin{tikzpicture}
% 	\begin{axis}[xlabel={Tamanho}, ylabel={Cache misses}, legend pos=north west]
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex0XXXX-l2dcm.txt' index 0};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex0XXXX-l2dcm.txt' index 1};
% 	\addplot gnuplot [raw gnuplot] {plot 'plots/ex0XXXX-l2dcm.txt' index 2};
% 	\legend{$16$, $32$ , $64$ }
% 	\end{axis}
% 	\end{tikzpicture}
% 	\caption{Comparação de cache-misses em memória cache L2 entre os diferentes tamanhos minimos.}
% 	\label{fig:exp0XXXX-l2dcm}
% \end{figure}



\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,references}
\end{document}
